<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hurricane Data Visualization</title>
    <script src="./hurricane-data-json.js"></script>
    <script src="./d3.js"></script>
  </head>
  <body>
    <script>
      let stack = d3.stack()
                    .keys("cat1 cat2 cat3 cat4 cat5".split(" "))
                    .order(d3.stackOrderReverse);

      let series = stack(bucketizedData2YR);

      let loadDataVis = () => {
        let w = 600, h = 200;
        let p = {top: 55, right: 20, bottom: 20, left: 20};

        let svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);

        let xScale = d3.scaleBand()
                       .domain(bucketizedData2YR.map(obj => obj.year))
                       .range([p.left, w - p.right])
                       .paddingInner(0.05);

        let yScale = d3.scaleLinear()
                       .domain([
                         d3.min(bucketizedData2YR, d => d.cat1 + d.cat2 + d.cat3 + d.cat4 + d.cat5),
                         d3.max(bucketizedData2YR, d => d.cat1 + d.cat2 + d.cat3 + d.cat4 + d.cat5)
                       ])
                       .range([h - p.top, p.bottom]);


        let xAxis = d3.axisBottom(xScale)
                      .ticks(10);
                      // .tickFormat(d3.timeFormat("%Y"));


        let yAxis = d3.axisLeft(yScale)
                      .ticks(3);

        let gx = svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + (h - p.top) + ")")
                    .call(xAxis);

        const rotateXTicks = axis => {
          axis.selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-65)" );
        };

        rotateXTicks(gx);
        // let nodeList = gx.selectAll("text")._groups[0];
        //
        // for(let i = 1; i < nodeList.length; i+=2) {
        //    nodeList[i].setAttribute("fill", "none");
        //  }

        let gy = svg.append("g")
                    .attr("class", "y axis")
                    .attr("transform", "translate(" + p.left + ", 0)")
                    .call(yAxis);

        let colors = d3.scaleOrdinal(d3.schemeCategory10);

        let groups = svg.selectAll("g.bargroups")
                        .data(series)
                        .enter()
                        .append("g")
                        .style("fill", d => {
                          if (d.key === "cat1" || d.key == "cat2") {
                            return "teal";
                          } else {
                            return "red";
                          }
                        });

        groups.append("title").text(d => d.key);

        let bars = groups.selectAll("rect")
                        .data(d => d)
                        .enter()
                        .append("rect")
                        .attr("x", d => xScale(d.data.year))
                        .attr("y", d => yScale(d[1]))
                        .attr("height", d => yScale(d[0]) - yScale(d[1]))
                        .attr("width", xScale.bandwidth());

        //Resources used to create best fit line were:
        //http://bl.ocks.org/benvandyke/8459843
        //https://www.varsitytutors.com/hotmath/hotmath_help/topics/line-of-best-fit

    		// let xSeries = dataset.map(d => xScale(d.year));
    		// let ySeriesAllHurricanes = dataset.map(d => yScale(d.cat1 + d.cat2 + d.cat3 + d.cat4 + d.cat5));
        //
    		// let LSAllHurricanes = leastSquares(xSeries, ySeriesAllHurricanes);
        //
        // //AH abbrev for All Hurricanes
    		// let x1 = xSeries[0];
    		// let y1AH = LSAllHurricanes[0] * x1 + LSAllHurricanes[1];
    		// let x2 = xSeries[xSeries.length - 1];
    		// let y2AH = LSAllHurricanes[0] * x2 + LSAllHurricanes[1];
        // console.log(`LSAllHurricanes`, LSAllHurricanes);
        // // console.log(y2AH, y1AH, x2, x1);
        // svg.append("line")
      	// 		.attr("class", "trendlineAllHurricanes")
      	// 		.attr("x1", x1)
      	// 		.attr("y1", y1AH)
      	// 		.attr("x2", x2)
      	// 		.attr("y2", y2AH)
      	// 		.attr("stroke", "black")
      	// 		.attr("stroke-width", 1);

        // let ySeriesMajorHurricanes = dataset.map(d => yScale(d.cat3 + d.cat4 + d.cat5));
        // let LSMajorHurricanes = leastSquares(xSeries, ySeriesMajorHurricanes);
        //
        // //MH abbrev for Major Hurricanes
    		// let y1MH = LSMajorHurricanes[0] * x1 + LSMajorHurricanes[1];
    		// let y2MH = LSMajorHurricanes[0] * x2 + LSMajorHurricanes[1];
        // console.log(`LSMajorHurricanes`, LSMajorHurricanes);
        //
        // svg.append("line")
      	// 		.attr("class", "trendlineMajorHurricanes")
      	// 		.attr("x1", x1)
      	// 		.attr("y1", y1MH)
      	// 		.attr("x2", x2)
      	// 		.attr("y2", y2MH)
      	// 		.attr("stroke", "black")
      	// 		.attr("stroke-width", 1);

        // function leastSquares(xSeries, ySeries) {
        //   let sumFunc = (a, b) => a + b;
        // 	let xBar = xSeries.reduce(sumFunc) / xSeries.length;
        // 	let yBar = ySeries.reduce(sumFunc) / ySeries.length;
        //
        // 	let ssXX = xSeries.map(x => Math.pow(x - xBar, 2))
        // 		                .reduce(sumFunc);
        //
        // 	let ssXY = xSeries.map((x, i) => (x - xBar) * (ySeries[i] - yBar))
        // 		                .reduce(sumFunc);
        //
        // 	let slope = ssXY / ssXX;
        // 	let intercept = yBar - (xBar * slope);
        //
        // 	return [slope, intercept];
        // }
      }

      loadDataVis();
    </script>
  </body>
</html>
