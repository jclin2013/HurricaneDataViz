<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hurricane Data Visualization</title>
    <script src="https://d3js.org/d3.v4.js"></script>
  </head>
  <body>
    <script>
      let parseYear = d3.timeParse("%Y");

      let rowConverter = d => {
        return {
          year: Number(d.Year),
          category: Number(d["Highest Saffir-Simpson Category (U.S.)"])
        };
      };

      let dataset;

      d3.csv("data.csv", rowConverter, d => {
        yearsWithoutHurricanes = [];
        for(let i = 0; i < d.length - 1; i++) {
          let currentYear = d[i].year;
          let nextYear = d[i + 1].year;
          if (nextYear - currentYear > 1) {
            currentYear++;
            while (currentYear < nextYear) {
              console.log(currentYear)
              yearsWithoutHurricanes.push({ year: currentYear });
              currentYear++;
            }
          }
        }

        d = d.concat(yearsWithoutHurricanes).sort((a, b) => a.year - b.year);

        dataset = d3.nest()
                    .key(d => d.year)
                    .rollup(v => v.filter(obj => obj.category).length)
                    .entries(d)
                    .map(obj => ({
                      year: parseYear(obj.key),
                      numOfHurricanes: obj.value
                    }));

        loadDataVis();
      });

      let loadDataVis = () => {
        let w = 500, h = 200;
        let p = {top: 20, right: 20, bottom: 20, left: 20};

        let svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);

        let xScale = d3.scaleTime()
                       .domain([
                         d3.min(dataset, d => d.year),
                         d3.max(dataset, d => d.year)
                       ])
                       .range([p.left, w - p.right]);

        let yScale = d3.scaleLinear()
                       .domain([
                         d3.min(dataset, d => d.numOfHurricanes),
                         d3.max(dataset, d => d.numOfHurricanes)
                       ])
                       .range([h - p.top, p.bottom]);


        let xAxis = d3.axisBottom(xScale)
                      // .ticks(50)
                      .tickFormat(d3.timeFormat("%Y"));

        let yAxis = d3.axisLeft(yScale)
                      .ticks(5);

        let gx = svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + (h - p.top) + ")")
                    .call(xAxis);

        let gy = svg.append("g")
                    .attr("class", "y axis")
                    .attr("transform", "translate(" + p.left + ", 0)")
                    .call(yAxis);

        let bars = svg.selectAll("rect")
                      .data(dataset)
                      .enter()
                      .append("rect")
                      .attr("x", d => xScale(d.year))
                      .attr("y", d => yScale(d.numOfHurricanes))
                      .attr("height", d => h - p.top - yScale(d.numOfHurricanes))
                      .attr("width", 2)
                      .attr("fill", "green");

        //Resources used to create best fit line were:
        //http://bl.ocks.org/benvandyke/8459843
        //https://www.varsitytutors.com/hotmath/hotmath_help/topics/line-of-best-fit

    		let xSeries = dataset.map(d => xScale(d.year));
    		let ySeries = dataset.map(d => yScale(d.numOfHurricanes));

    		let leastSquaresCoeff = leastSquares(xSeries, ySeries);

    		let x1 = xSeries[0];
    		let y1 = leastSquaresCoeff[0] * x1 + leastSquaresCoeff[1];
    		let x2 = xSeries[xSeries.length - 1];
    		let y2 = leastSquaresCoeff[0] * x2 + leastSquaresCoeff[1];

        svg.append("line")
      			.attr("class", "trendline")
      			.attr("x1", x1)
      			.attr("y1", y1)
      			.attr("x2", x2)
      			.attr("y2", y2)
      			.attr("stroke", "black")
      			.attr("stroke-width", 1);

        function leastSquares(xSeries, ySeries) {
          let sumFunc = (a, b) => a + b;
        	let xBar = xSeries.reduce(sumFunc) / xSeries.length;
        	let yBar = ySeries.reduce(sumFunc) / ySeries.length;

        	let ssXX = xSeries.map(x => Math.pow(x - xBar, 2))
        		                .reduce(sumFunc);

        	let ssXY = xSeries.map((x, i) => (x - xBar) * (ySeries[i] - yBar))
        		                .reduce(sumFunc);

        	let slope = ssXY / ssXX;
        	let intercept = yBar - (xBar * slope);

        	return [slope, intercept];
        }
      }
    </script>
  </body>
</html>

<!-- [
{year: cat1: cat2: cat3: cat4: cat5: sum:}
] -->
